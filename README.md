# Database
<DB 1일차><br>
DB(DataBase) : 자료를 영구적으로 저장하는 것   -> 정형 데이터, 비정형 데이터로 나뉨
그 중 정형데이터인 "관계형데이터베이스"--도구(정보를 훨씬 더 빠르고 편리하게 저장가능하게 도와주는 도구임)
---> Oracle(우리가 사용할 프로그램), Mysql, Maria(프로젝트시 사용 권장), Mssql   이 관계형데이터베이스 프로그램

ex) 저장할 자료: 고객의정보(릴레이션 이름)
	<표 - 전체: 릴레이션>
-> 번호(숫자)  / 이름(문자)  / 나이  / 주소  / 전화번호  를 정의해서 저장함
->     1             홍길동        37      수원     1111     ->  행 1
        2             김길수        25      서울     2222     ->  행 2
        3             홍길동        34      대전     3333     ->  행 3
      (열1)	        (열2)        (열3)     (열4)    (열5)
-> 한글에 저장하면, 한글로 데이터베이스를 만든것.
    엑셀  ,,           , 엑셀로    ,,

- 관계형 데이터베이스 용어 -
릴레이션(테이블)---> 표 전체를 릴레이션(테이블)이라고 함
    -> 이러한 릴레이션은 행(로우, 3줄-> 분류기준인 줄은 행으로 포함X)과 열(컬럼, 5개)로 만들어짐.
    -> 행(로우)은 '저장할 대상의 자료'(의미있는 데이터만 행이라고 함. 즉 위에 항목은 포함 안되는 이유)
    -> 열(컬럼)은 '의미'를 가짐  -> 컬럼은 한글아니면 숫자를 지정할 수 있음
	-> ****** 즉, 컬럼에 속성과 제약조건(들어가는 값을 디테일하게 설정)을 지정할 수 있음 ******
	      (예를 들어 속성은 숫자로,
		제약조건은 not null(반드시 입력해야함) /
			  check(체크항목) /
		   	  unique(하나의 값만 가져야함-번호)->딱 하나의 값만 찾아내기 위한 값...
                   이런식)
    	-> + - 필요하면 숫자  /  필요없으면 문자로..   (예를 들어 전화번호의 경우는 덧셈.뺄셈 필요없으므로 문자로 지정 O)
    -> 무결성 위배: 결함이 없어야하는데 결함이 생김을 의미
          (예를들어 번호 3을 가진 사람이 2명 생긴 경우  ...  신뢰성이 깨졌다!)

-> 테이블을 만든다는 것은 컬럼을 만든다는 것을 의미함
    (로우가 없어도, 컬럼만 있는 테이블이 될 수 있음)
    (반대로 컬럼이 없고, 로우만 있다면, 테이블이 될 수 없음 -> 분류기준을 알 수 없음)

- 명령어 -
생각해낸 정보들로 테이블을 만드는 것 -> 개념적인 모델링
Create table :  내가 개념적으로 생각한 테이블을 실제로 만들거야.
-> Create table 고객의 정보(릴레이션 이름)	-> 실제로는 절대 한글로 입력하면 안됨! 영어로!)
    (컬럼명 속성 제약조건)
    번호 number unique key,    		-> 컬럼 1(중복불가)
    이름 varchar2(6)	 not null,    		-> 컬럼 2(6바이트, 한글 3글자까지 가능)(반드시 입력)
    나이 number(2)	defalut 1,    		-> 컬럼 3(두자리까지 가능)(처음부터 1의 값으로 시작)
    주소 varchar2(50)    	     	     	-> 컬럼 4(50바이트, 한글 25글자까지 가능)
);

<hr>

<DB - 2일차>
<br>
CRUD(table에 CRUD작업을 하는 것)
-> C : row insert
-> R : row select
-> U : row update
-> D : row delete
    ↑  서버에서 처리해서 DB로
서버(java)
    ↑  서버로 데이터 전송
게시판(View) : 글쓰기(C), 글수정(U), 글삭제(D), 검색(S), 전체보기(S), 좋아요 누르기(C), 추천하기(C)

DB -> 정형(테이블과 같은 형태가 존재하는 데이터 / 사용하는 프로그램 : oracle, mysql,maria,mssql)  
         vs 비정형

테이블 -> 행(row)은 CRUD와 관련, 열(column)은 속성과 제약조건과 관련
         -> 키 : 컬럼에 부여하는 기능(기본키, 외래키)\

** 컬럼에 제약조건을 거는 것과, 어떠한 기능을 부여하는 것인 키와 다름

기본키 : 튜플(row)을 유일하게 식별할 수 있음,
           기본키로 index(색인)(검색속도가 향상)를 형성하여 저장함,
           null이 불가(즉, not null을 포함)함.

이름	 주소	 전화번호
홍길동     서울	  1111
일지매	 서울	  1111
홍길동	 수원	  2222

-> 이러한 테이블의 경우 문제점찾아보기
: update나 delete의 경우, 튜플을 유니크하게 식별하지 못하기 때문에 각 이상현상이 발생함.
-> 하지만 각각의 컬럼에 제약조건을 unique로 하게되면, 너무 제한적이여서 문제가 발생함
-> 유니크한 값인, 즉 고유한 ID와 같은 항목으로 컬럼을 하나 더 만들어서 이러한 문제를 해결할 수 있음
-> 튜플을 유니크하게 식별하기 위함,,
-> 테이블작성시 신경써야할 부분 : 갱신이상(이상현상)을 고려** + 쿼리의 속도가 빨라야함**
-> 이상현상은 unique가 해결할 수 있으며(유일성), 검색속도는 인덱스가 해결할 수 있음(속도향상).
---> 이러한 두가지 역할을 동시에 할 수 있는 것이 "기본키"임!!!!!!!!!  ★ ★ ★

create table m(
   ID varchar2(1) primary key,    ->  이런식으로 ID 에 기본키를 부여하여 코드를 작성할 수 있음
   name varchar2(2),
   add varchar2(10)
);

ex) 회사는 자동차를 등록한다. 한사람이 여러대 등록가능
 ID	이름	전번	카번호
 a	 홍	1111	  1
 a	 홍	1111	  2
-> 이상현상이 발생
-> unique값을 id에 부여하면 같은사람이 여러개의 차를 등록할 수 없음

테이블 설계시에, 이상현상을 고려(-> 1. 유일성을 보장 / 2. 데이터의 중복을 최소화 -> 정규화를 진행)
-> 테이블을 분리하여 작성 (정규화: 데이터 중복을 최소화하기 위해서!!!!★ ★ ★)
 1번테이블 (member,부모릴레이션)
 ID(기본키) 이름	전번
 a	   홍	1111
 b	   홍	2222

 2번테이블 (car, 자식릴레이션)
 카번호	ID(외래키)
  1	 a
  2	 a

-> 1번 테이블(member, 부모릴레이션) : ID(기본키로 지정) 이름 전번   -> 이렇게만 작성하여 데이터 중복을 막아줌
-> 2번 테이블(car, 자식릴레이션) : 카번호 ID(외래키) -> ID의 외래키로, 누구의 차인지 식별가능하게 해줌.(연관성부여)
    -> 외래키는 1번테이블의 ID를 참조한다.
    -> 자식릴레이션의 외래키로 지정된 컬럼은 부모릴레이션의 특정 컬럼을 참조한다.★ ★ ★(컬럼 to 컬럼)

<hr>

<DB-3일차><br>
ERD(프로젝트의 컨셉이 나오면 시나리오를 보고 이러한 데이터를 저장하기 위해 하는 것)
: E - 개체(독립적으로 존재할 수 있는 대상)
  / R - 관계 (개체와 개체가 가지는 관계, 혼자 독립할 수 없는 것을 의미)
  / D - diagram
: '개념적 설계'에 해당 (이 다음에 논리적(테이블 명세서)->물리적 단계(쿼리문 작성)임)

시나리오에서 독립적으로 존재할 수 있는 것
-> 개체 (하지만, 개체가 테이블과 같다는 말은 틀림)
     (테이블을 만들기 위한 과정으로, 도식화의 과정임. 즉 이 단계에서는 테이블이 존재하지 않음)
     (도식화된 개체가 테이블로 형성되지 못할 수 있음)

ex1) 고객의 출석에 대해서 관리하고 싶다(출석은 고객없이 독립적으로 존재할 수 없다-관계)
    고객(개체)  -  id(밑줄-기본키)   name    (속성값 2개, attribute)
        |
   <다이아몬드 - 출석>     -> 두 개체간의 관계성을 찾는 것.
        |  
    출석대장(개체) - 시간


ex2) 교수(id, 이름)는 논문을 작성. 논문은 작성일 아이디만 저장.
   교수(개체) - 아이디(밑줄-기본키)   이름    (속성값 2개, attribute)
        |
  <다이아몬드 - 작성>     -> 두 개체간의 관계성을 찾는 것.
        |  
   논문(개체) - 작성일  아이디 / 번호(unique한 속성필요)


-관계의 종류  --> 1:1 , 1:N, N:M
1:1의 관계에서는 굳이 테이블을 나누지않고, 하나의 테이블로 작성.
1:N이면, 1인 테이블이 부모, N의 테이블이 자식.
N:M이면, 각각 개체에 대한 테이블(총 2개)과,
            관계에 대한 테이블을 자식테이블로 작성(외래키 2개)(이 테이블의 단독적인 기본키 하나 추가로 생성)

--관계에도 속성이 들어갈 수 있음(다이아몬드에도 동그라미의 속성 붙일 수 있음)
   -> 이 속성은 N의 테이블의 속성으로 테이블 작성

  <관계구도 정리해보기>

![image](https://github.com/user-attachments/assets/2bdccf34-b576-490c-b910-98ecfdecf88b)


외래키 지정-> 참조하고 있는 부모의 내용이 삭제되면
-> 그에 따라서 자식 릴레이션 내용도 삭제: '외래키 지정내용~~~' + on delete cascade
-> 그에 따라서 자식 릴레이션 내용 null: '외래키 지정내용~~~' + on delete set null
ex) costraint fk_reg_cus foreign key(reg_event) references customer(id) on delete cascade
     또는
    costraint fk_reg_cus foreign key(reg_event) references customer(id) on delete set null
