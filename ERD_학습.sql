ERD(프로젝트의 컨셉이 나오면 시나리오를 보고 이러한 데이터를 저장하기 위해 하는 것)
: E - 개체(독립적으로 존재할 수 있는 대상)
  / R - 관계 (개체와 개체가 가지는 관계, 혼자 독립할 수 없는 것을 의미)
  / D - diagram
: '개념적 설계'에 해당 (이 다음에 논리적(테이블 명세서)->물리적 단계(쿼리문 작성)임)
시나리오에서 독립적으로 존재할 수 있는 것
-> 개체 (하지만, 개체가 테이블과 같다는 말은 틀림)
(테이블을 만들기 위한 과정으로, 도식화의 과정임. 즉 이 단계에서는 테이블이 존재하지 않음)
(도식화된 개체가 테이블로 형성되지 못할 수 있음)


ex1) 고객의 출석에 대해서 관리하고 싶다(출석은 고객없이 독립적으로 존재할 수 없다-관계)
고객(개체)  -  id(밑줄-기본키)   name    (속성값 2개, attribute)
|
<다이아몬드 - 출석>     -> 두 개체간의 관계성을 찾는 것.
|

출석대장(개체) - 시간


ex2) 교수(id, 이름)는 논문을 작성. 논문은 작성일 아이디만 저장.
교수(개체) - 아이디(밑줄-기본키)   이름    (속성값 2개, attribute)
|
<다이아몬드 - 작성>     -> 두 개체간의 관계성을 찾는 것.
|

논문(개체) - 작성일  아이디 / 번호(unique한 속성필요)




-관계의 종류  --> 1:1 , 1:N, N:M
1:1의 관계에서는 굳이 테이블을 나누지않고, 하나의 테이블로 작성.
1:N이면, 1인 테이블이 부모, N의 테이블이 자식.
N:M이면, 각각 개체에 대한 테이블(총 2개)과,
            관계에 대한 테이블을 자식테이블로 작성(외래키 2개)(이 테이블의 단독적인 기본키 하나 추가로 생성)
--관계에도 속성이 들어갈 수 있음(다이아몬드에도 동그라미의 속성 붙일 수 있음)
-> 이 속성은 N의 테이블의 속성으로 테이블 작성


외래키 지정-> 참조하고 있는 부모의 내용이 삭제되면
-> 그에 따라서 자식 릴레이션 내용도 삭제: '외래키 지정내용~~~' + on delete cascade
-> 그에 따라서 자식 릴레이션 내용 null: '외래키 지정내용~~~' + on delete set null
ex) costraint fk_reg_cus foreign key(reg_event) references customer(id) on delete cascade
또는
costraint fk_reg_cus foreign key(reg_event) references customer(id) on delete set null



